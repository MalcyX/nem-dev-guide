+++
prev = "09-mosaics"
next = "80-debugging"
weight = 100
title = "Developing an application"
toc = true
+++

In this chapter we will develop a small application: an offline transfer transactions signer for the test network.
It will consist of a desktop application built on Electron, that will let you generate and a transaction
without network connection. It is a way to secure a private key from being compromised. Adapting the applications
to work on the main net is trivial (we will underline what minor changes are needed).

When the signed transaction has been generated, it needs to be broadcasted to the network. That will be done
from an Android application. The Android application will scan a QR-code displayed by the desktop application, and
will send the encoded transaction to the NEM network.

## Security consideration

It is interesting to note that, if a multisig transaction is generated by the desktop app and another co-signatory is required 
to sign the transaction for it to go through, and the co-signatory signing the transaction 
has no fund, the user can use this application without the need of trusting the developer of the application.

As another co-signatory needs to sign the transaction, you/he/she can check that the broadcated transaction is what was meant.
Even if the desktop application were infected with malware, it wouldn't be able to fraudulously transfer funds.
And as the Android application is simply a broadcaster of the scanned transaction, it doesn't and can't compromise the transfer of
funds.


## Offline signer

To develop our desktop offline signer, we will use the [electron-quick-start](https://github.com/electron/electron-quick-start) as a base.
We will follow their instructions to install it:
```
# Clone this repository
git clone https://github.com/electron/electron-quick-start
# Go into the repository
cd electron-quick-start
# Install dependencies
npm install
# Run the app
npm start
```

If all went well, the last step opens an empty window. This is the base application we will build on.

### Dependencies

We first add our dependencies: nem-library, rxjs (for nem-library) and qrcode (to display the transaction as a qrcode).
You add them in `package.json`, just after the `devDependencies` entry, like this:
```
  "devDependencies": {
    "electron": "~1.7.8"
  },
  "dependencies": {
    "nem-library": "~0.10.0",
    "rxjs": "~5.5.0",
    "qrcode": "~0.9.0"
   }

```
You can see the diff of [this commit](https://github.com/rb2nem/electron-quick-start/commit/41d4d0a51964ae3d63720806a627c1acdc93004f) on Github.

Now run the command 
```
npm install
```

to install all new dependencies.

### Window content

We then edit the `index.html` file. This is the content of the application's window. We need to add input fields to get the data required to 
instanciate a transaction. These are:

* the signer's private key
* the recipient of the transfer
* the amount of XEMs transferred
* the message of the transaction
* to be able to sign multisig transactions, we will also include a field for the multisig account's public key

Edit the `index.html` file. You can remove everything inside the `<body>` tag, except for the `<script>` tag, which 
should be left in place, at the bottom.

In the body tag, we add this old school, table-based, HTML:

```
<table>
<tr><td>signer private key:</td><td><input type="text" id="pk" size="64"/></td></tr>
<tr><td>recipient:</td><td><input type="text" id="recipient" size="64"/></td></tr>
<tr><td>amount:</td><td><input type="text" id="amount"</td></tr>
<tr><td>message:</td><td>
    <textarea id="msg"></textarea>
</td></tr>
<tr><td>Multisig public key:</td><td><input type="text" id="msig_pubkey" size="64"/></td></tr>
<tr><td><button id="send">SEND</button></td></td></tr>
</table>

```

With this information provided, we will generated the transfer transaction, sign it with the private key provided, and
serialise it to be broadcasted to the network. This JSON serialised transaction will then be displayed as text and as
 a QR code. The HTML to display both is a `div` to display the JSON, and a canvas to display the QR-code:

```
<div style="width:100%;">
    <div id="result" style="width:75%;word-wrap:break-word;">
    </div>
    <canvas id="canvas">
    </canvas>
</div>
```

You can see the diff of [this commit](https://github.com/rb2nem/electron-quick-start/commit/991318a57736de0c5844ba5825b7b54f52e63169) on Github.
This results in this window content:

{{< figure src="/images/app_signer_window_fields.png" title="Offline Signer Window" >}}

And this is what needs to be tweaked in the application's window content. You
can of course further change the content of the `index.html` file to better
suit your needs and taste. We will however focus on the code needed to make this app work.

### Code

We will start by removing the menu, which we don't use. 
This is done by editing the file `main.js` and adding the line
```
mainWindow.setMenu(null);
```

right after the initialisation of the main window in the function `createWindow`.

You can see the diff of [this commit](https://github.com/rb2nem/electron-quick-start/commit/91f34638efa62c3b87ef8838e0c79d131d7f5a66) on Github.

It is also in `main.js` that you can activate the developer tools, which are 
invaluable when you want to debug your application. To have the developers tools
active, just be sure that this line is not commented:
```
mainWindow.webContents.openDevTools()
```

Here is a screenshot of our app with the dev tool opened:
{{< figure src="/images/app_dev_tools.png" title="Developer tools" >}}


But the bulk of our code is in the file `rendered.js`.
We start by requiring all dependencies:
```
const $ = require('jquery');
const nemLibrary = require("nem-library");
const NEMLibrary = nemLibrary.NEMLibrary,
    Address = nemLibrary.Address,
    NetworkTypes = nemLibrary.NetworkTypes,
    TimeWindow = nemLibrary.TimeWindow,
    TransferTransaction = nemLibrary.TransferTransaction,
    MultisigTransaction = nemLibrary.MultisigTransaction,
    TransactionHttp = nemLibrary.TransactionHttp,
    XEM = nemLibrary.XEM,
    EmptyMessage = nemLibrary.EmptyMessage,
    Account = nemLibrary.Account,
    PublicAccount = nemLibrary.PublicAccount,
    PlainMessage = nemLibrary.PlainMessage;
const QRCode = require('qrcode');
```

We will use jquery in our code, to access elements of the interface we defined
in `index.html`, and all other lines are nem-library elements we will use.

The first this with nem-library is to bootstrap the environment for the network we will use:

```
NEMLibrary.bootstrap(NetworkTypes.TEST_NET);
```

In our case, it will always be the testnet, but should you want to work on the mainnet, this is the
only line you would change. A final application would probably display a dropdown list or a radio button
to select the network for which to generate the transaction.

We can now write the code to generate the signed transaction and display it as string and qr-code.
We will put this code in the function `computeSignedTransaction`.

We start by extracting values entered by the user:
```
        var privateKey = $("#pk").val();
        var recipient =  $("#recipient").val();
        var amount =  $("#amount").val();
        var message = $("#msg").val();
        var msig_pubkey = $("#msig_pubkey").val();
```

With this info, we can create the transfer transaction:

```
       let transferTransaction = TransferTransaction.create(
           TimeWindow.createWithDeadline(),
           new Address(recipient),
           new XEM(amount),
           PlainMessage.create(message)
       );
```

We wanted to also support initiating multisig transactions.
With nem library, handling a multisig transaction is just a question of
wrapping the transfer transaction with a MultisigTransaction.
We will do this only if a public key of the multisig account is provided,
resuting in this code:

```
       // tx will be the transaction signed.
       // if multisig, it is reassigned below
       let tx = transferTransaction;
    
       // if we have a public key, create a multisig transaction
       if (msig_pubkey!="") {
               tx = MultisigTransaction.create(
                   TimeWindow.createWithDeadline(),
                   transferTransaction,
                   PublicAccount.createWithPublicKey(msig_pubkey)
               );
       } 
```

We can then sign the transaction with the account for which we received 
the private key from the user. We immediately stringify the JSON of the
signed transaction:
```
       let account = Account.createWithPrivateKey(privateKey);
       let signedTransaction = account.signTransaction(tx);
       let text=JSON.stringify(signedTransaction);
```

Now we have the text to display. We set the transaction text ad the content of the div with id `result`:
```
       $("#result").html(text);

```
and we display it as qrcode:
```
       var canvas = document.getElementById('canvas')
        
       QRCode.toCanvas(canvas,text, function (error) {
         if (error) console.error(error)
       })

```

The only thing left to do is attaching our function to the click of button `send`:
```
$("#send").on('click', computeSignedTransaction);
```

That's really all there is. 

You can see the diff of [this commit](https://github.com/rb2nem/electron-quick-start/commit/4a498f31adb1a30c659548aaeb9040f2f91101f3) on Github.

Here is an example of a signed transaction:

{{< figure src="/images/app_signer.png" title="Offline Signer Result" >}}

